/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.prove.proveapi.hooks;

import java.io.InputStream;
import java.lang.reflect.Field;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

import com.prove.proveapi.SecuritySource;
import com.prove.proveapi.utils.Constants;
import com.prove.proveapi.utils.Helpers;
import com.prove.proveapi.utils.HTTPClient;
import com.prove.proveapi.utils.Hook.AfterError;
import com.prove.proveapi.utils.Hook.AfterErrorContext;
import com.prove.proveapi.utils.Hook.BeforeRequest;
import com.prove.proveapi.utils.Hook.BeforeRequestContext;
import com.prove.proveapi.utils.Hook.HookContext;
import com.prove.proveapi.utils.Hook.SdkInit;
import com.prove.proveapi.utils.Hook.SdkInitData;
import com.prove.proveapi.utils.SessionManager;
import com.prove.proveapi.utils.SessionManager.HasSessionKey;
import com.prove.proveapi.utils.SessionManager.Session;
import com.prove.proveapi.utils.Security;
import com.prove.proveapi.utils.Utils;

public final class ClientCredentialsHook implements SdkInit, BeforeRequest, AfterError {

    private final SessionManager<Credentials> sessions;

    // set by sdkInit
    private String baseUrl;
    private HTTPClient client;

    public ClientCredentialsHook() {
        this.sessions = new SessionManager<Credentials>();
    }

    @Override
    public SdkInitData sdkInit(SdkInitData data) {
        baseUrl = data.baseUrl();
        client = data.client();
        return new SdkInitData(baseUrl, client);
    }

    @Override
    public HttpRequest beforeRequest(BeforeRequestContext context, HttpRequest request) throws Exception {
        if (isHookDisabled(context)) {
            return request;
        }
        final Credentials credentials;
        Optional<Credentials> c = credentials(context.securitySource());
        if (c.isPresent()) {
            credentials = c.get();
        } else {
            return request;
        }
        List<String> requiredScopes = getRequiredScopes(credentials, context);
        Session<Credentials> session = sessions.getSession(credentials, requiredScopes,
                scopes -> doTokenRequest(context.baseUrl(), client, credentials, scopes, Constants.HAS_CLIENT_CREDENTIALS_BASIC));
        return Helpers.copy(request) //
                // overwrites any previous value
                .setHeader("Authorization", "Bearer " + session.token().orElse("")) //
                .build();
    }

    @Override
    public HttpResponse<InputStream> afterError(AfterErrorContext context, Optional<HttpResponse<InputStream>> response,
            Optional<Exception> error) throws Exception {
        if (isHookDisabled(context)) {
            return response.get();
        }

        if (error.isPresent()) {
            throw error.get();
        }

        Optional<Credentials> credentials = credentials(context.securitySource());
        if (!credentials.isPresent()) {
            return response.get();
        }

        if (response.get().statusCode() == HttpURLConnection.HTTP_UNAUTHORIZED) {
            String sessionKey = credentials.get().sessionKey();
            List<String> requiredScopes = getRequiredScopes(credentials.get(), context);
            String scopeKey = getScopeKey(requiredScopes);
            sessions.removeSession(sessionKey, scopeKey);
        }
        return response.get();
    }

    private static String getScopeKey(List<String> scopes) {
        if (scopes == null || scopes.isEmpty()) {
            return "";
        }

        List<String> sortedScopes = new java.util.ArrayList<>(scopes);
        sortedScopes.sort(String::compareTo);
        return String.join("&", sortedScopes);
    }

    private static Boolean isHookDisabled(HookContext context) {
        return !context.oauthScopes().isPresent();
    }

    private static Session<Credentials> doTokenRequest(String baseUrl, HTTPClient client, Credentials credentials,
            List<String> scopes, boolean hasClientCredentialsBasic) {
        Map<String, String> payload = new HashMap<>();
        Map<String, String> headers = new HashMap<>();

        payload.put("grant_type", "client_credentials");
        if (hasClientCredentialsBasic) {
            headers.put("Authorization", "Basic "
                + Base64.getEncoder()
                .encodeToString(String.format("%s:%s", credentials.clientId, credentials.clientSecret)
                                      .getBytes(StandardCharsets.UTF_8)));
        } else {
            payload.put("client_id", credentials.clientId);
            payload.put("client_secret", credentials.clientSecret);
        }
        if (scopes.size() > 0) {
            payload.put("scope", scopes.stream().collect(Collectors.joining(" ")));
        }
        URI tokenUri = URI.create(baseUrl).resolve(credentials.tokenUrl);
        return SessionManager.requestOAuth2Token(client, credentials, scopes, payload, headers, tokenUri);
    }

    // VisibleForTesting
    final static class Credentials implements HasSessionKey {
        final String clientId;
        final String clientSecret;
        final String tokenUrl;
        final List<String> scopes;

        Credentials(String clientId, String clientSecret, String tokenUrl, List<String> scopes) {
            Utils.checkNotNull(clientId, "clientId");
            Utils.checkNotNull(clientSecret, "clientSecret");
            Utils.checkNotNull(tokenUrl, "tokenUrl");
            this.clientId = clientId;
            this.clientSecret = clientSecret;
            this.tokenUrl = tokenUrl;
            this.scopes = scopes;
        }

        @Override
        public String sessionKey() {
            return Utils.sessionKey(clientId, clientSecret);
        }
    }

    private static Optional<Credentials> credentials(Optional<SecuritySource> source) {
        if (!source.isPresent()) {
            return Optional.empty();
        }
        Object security = source.get().getSecurity();
        if (security == null) {
            return Optional.empty();
        }

        // To find credentials we use reflection-based inspection of the SpeakeasyMetadata
        // annotated fields in the object graph of `security`.

        // Look recursively for a non-empty complex field (not just a String) that holds
        // client credentials and use the first one found. If present then is nested security
        // and we treat the field value as the security object when we search for the client credentials specific fields.

        Object sec = Security.findComplexObjectWithNonEmptyAnnotatedField(security,
                        "\\bscheme=true\\b",
                        "\\btype=oauth2\\b",
                        "\\bsubtype=client_credentials\\b")
                    .orElse(security);

        Optional<String> clientId = oauth2FieldValue(sec, "clientID");
        Optional<String> clientSecret = oauth2FieldValue(sec, "clientSecret");
        Optional<String> tokenUrl = fieldValue(sec, "tokenURL", String.class);
        @SuppressWarnings("unchecked") // prevent generic type erasure warning
        List<String> scopes = (List<String>) fieldValue(sec, "scopes", List.class).orElse(null);

        if (clientId.isEmpty() || clientSecret.isEmpty() || tokenUrl.isEmpty()) {
            return Optional.empty();
        } else {
            return Optional.of(new Credentials(clientId.get(), clientSecret.get(), tokenUrl.get(), scopes));
        }
    }

    private static Optional<String> oauth2FieldValue(Object security, String name) {
        return Security.findStringValueWhereMetadataNameIs(security, name);
    }

    @SuppressWarnings("unchecked")
    private static <T> Optional<T> fieldValue(Object o, String fieldName, Class<T> type) {
        try {
            Field field = o.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            Object value = field.get(o);
            if (value instanceof Optional) {
                Optional<T> optionalValue = (Optional<T>) value;
                return optionalValue.isPresent() ? optionalValue : Optional.empty();
            } else if (type.isInstance(value)) {
                return Optional.of((T) value);
            } else {
                return Optional.empty();
            }
        } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) {
            return Optional.empty();
        }
    }

    private static List<String> getRequiredScopes(Credentials credentials, HookContext context) {
        if (credentials.scopes != null) {
            return credentials.scopes;
        }
        return context.oauthScopes().orElse(List.of());
    }
}
